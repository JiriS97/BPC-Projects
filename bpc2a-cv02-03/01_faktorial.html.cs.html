<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-2">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice 4.1.3  (Win32)">
	<META NAME="AUTHOR" CONTENT="M R">
	<META NAME="CREATED" CONTENT="20140211;9232825">
	<META NAME="CHANGEDBY" CONTENT="Richter">
	<META NAME="CHANGED" CONTENT="20170215;9393553">
	<META NAME="CHANGEDBY" CONTENT="Richter">
	<META NAME="CHANGEDBY" CONTENT="Richter">
	<META NAME="CHANGEDBY" CONTENT="Richter">
	<META NAME="CHANGEDBY" CONTENT="Richter">
	<META NAME="CHANGEDBY" CONTENT="Richter">
	<META NAME="CHANGEDBY" CONTENT="M R">
	<META NAME="CHANGEDBY" CONTENT="M R">
	<META NAME="CHANGEDBY" CONTENT="M R">
	<META NAME="CHANGEDBY" CONTENT="M R">
	<META NAME="CHANGEDBY" CONTENT="M R">
	<STYLE TYPE="text/css">
	<!--
		@page { size: 21cm 29.7cm; margin-left: 2cm; margin-right: 1cm; margin-top: 1cm; margin-bottom: 1cm }
		P { margin-bottom: 0.21cm }
		PRE.western { font-family: "Courier New", monospace; font-size: 10pt }
		PRE.cjk { font-family: "NSimSun", monospace; font-size: 10pt }
		PRE.ctl { font-family: "Courier New", monospace; font-size: 10pt }
		TD P { color: #000000 }
		CODE.western { font-family: "Courier New", monospace }
		CODE.cjk { font-family: "NSimSun", monospace }
		CODE.ctl { font-family: "Courier New", monospace }
		A:link { color: #000080; so-language: zxx; text-decoration: underline }
		A:visited { color: #800000; so-language: zxx; text-decoration: underline }
	-->
	</STYLE>
</HEAD>
<BODY LANG="cs-CZ" LINK="#000080" VLINK="#800000" DIR="LTR">
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0 STYLE="page-break-before: always">
	<COL WIDTH=85*>
	<COL WIDTH=85*>
	<COL WIDTH=85*>
	<TR VALIGN=TOP>
		<TD WIDTH=33%>
			<P ALIGN=JUSTIFY STYLE="widows: 8"><FONT SIZE=3><B><A HREF="../../../index.html.cz">Home
			page</A></B></FONT></P>
		</TD>
		<TD WIDTH=33%>
			<P ALIGN=CENTER STYLE="widows: 4"><A HREF="../main_pc2.html.cs">PC2A
			home page</A></P>
		</TD>
		<TD WIDTH=33%>
			<P ALIGN=RIGHT STYLE="widows: 2"><A HREF="../../index.html.cs">Výuka
			home page</A></P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=6 STYLE="font-size: 22pt"><B>Faktoriál</B></FONT></P>
<P ALIGN=CENTER><FONT SIZE=2 STYLE="font-size: 11pt"><B>(2017)</B></FONT></P>
<P><BR><BR>
</P>
<P><FONT SIZE=4 STYLE="font-size: 16pt"><B>Princip volání funkce,
podprogramu</B></FONT></P>
<P>Funkce slou¾í k dìlení programu na logické èásti, èím¾ zlep¹uje
èitelnost programu. Umo¾òuje pou¾ití stejného kódu v rùzných místech
(za pomoci volání, odskoku do podprogramu). Realizace funkce (tj.
instrukce, které ji reprezentují), je v pamìti pouze jednou. 
</P>
<P>Funkce se mohou volat navzájem &ndash; rozli¹ujeme potom funkci
volající a funkci volanou. Volající funkce &bdquo;zavolá&ldquo;
funkci volanou pomocí instrukce skoku do podprogramu &bdquo;call&ldquo;
(na rozdíl od instrukce &bdquo;prostého&ldquo; skoku umístí &bdquo;call&ldquo;
na zásobník adresu následující instrukce, proto¾e po ukonèení volané
funkce se musí pokraèovat z místa programu, ze kterého se
&bdquo;odskoèilo&ldquo;). Volaná funkce potom provede svou èinnost a
je ukonèena returnem &bdquo;return&ldquo; zajistí skok na adresu v
programu, kterou na zásobník ulo¾il &bdquo;call&ldquo;.</P>
<P>Volající a volaná funkce (v jazyce C/C++) sdílí data pøes
parametry/argumenty a návratovou hodnotu. Parametry jsou uvedeny svým
typem a názvem v hlavièce funkce a jsou to lokální promìnné funkce
(jejich ¾ivot konèí s instrukcí návratu z funkce). Návratová hodnota
je uvedena pouze svým typem a nemá jméno - &bdquo;zùstane&ldquo; po
vykonání funkce jako její výsledek a dá se vyu¾ít ve výrazech jako
promìnná daného typu (typ dán návratovou hodnotou). Poté co je
pou¾ita v daném výrazu (ve kterém je volána funkce) návratová hodnota
&bdquo;mizí&ldquo; a ji¾ není k dispozici.</P>
<P>Pamì»ové místo pro parametry funkce i pro návratovou hodnotu je
vyhrazeno na zásobníku. Volající i volaná funkce si v¹ak musí
rozumnìt v typu a poètu parametrù. Proto je nutné aby pøed voláním
funkce znal pøekladaè její prototyp (jméno a typy argumentù a
návratové hodnoty. Na základì této informace pøekladaè nejen vyhradí
správné místo na zásobníku, ale pokud je to nutné, tak provede i
konverzi parametru z typu promìnné pou¾ité ve volání na typ oèekávaný
(je-li ve volání funkce, která oèekává typ int promìnná typu double,
je vyhrazeno místo na int a promìnná typu double je pøevedena na typ
int a ulo¾ena do pøipraveného místa). Pro informování pøekladaèe o
prototypech funkce slou¾í uvedení prototypù do hlavièkového souboru,
který tímto oznamuje pøekladaèi jak má realizovat volání (konverze na
typ oèekávaný volanou funkcí).</P>
<P>S voláním funkce je spojená re¾ie, spoèívající ve &bdquo;spotøebì&ldquo;
pamìti a èasu. Pamì» je nutná k vytvoøení a ulo¾ení pøedávaných
promìnných, nìkdy je je¹tì pøed voláním funkce nutné &bdquo;uklidit&ldquo;
registry procesoru (ulo¾it je na zásobník), proto¾e volaná funkce je
mù¾e pou¾ít pro své výpoèty a tím pøemazat v nich ulo¾ená data. Po
ukonèení funkce jsou tato data vrácena zpìt do pøíslu¹ných registrù.
Dále je nutné ulo¾it návratovou adresu. Tato manipulace s pamìtí a
èasová re¾ie pro &bdquo;skoky&ldquo; na jiné adresy trvá nìjaký èas &ndash;
èasová re¾ie volání funkce.</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><FONT SIZE=4 STYLE="font-size: 16pt"><B>Rekurzivní funkce</B></FONT></P>
<P>Jsou funkce, které volají samy sebe (nejèastìji pøímo, ale mù¾e k
tomu dojít i nepøímo (zprostøedkovanì)). Pou¾ívá se pøi øe¹ení
slo¾itìj¹ích úloh (napøíklad neuronové sítì, expertní systémy), pøi
hledání øe¹ení, kdy se upraví parametry a zavolá se tatá¾ funkce. 
</P>
<P>Napøíklad výpoèet faktoriálu lze vyjádøit funkcí, kdy se ve
výpoètu opìt vystupuje faktoriál: X! = X (X-1)!, kde výraz (X-1)! se
poèítá opìt podle tohoto vzorce. Tento vzorec se pou¾ije pro X &gt;
0, s èím¾ souvisí ukonèovací podmínka (aby se z toho nestal nekoneèný
algoritmus konèící pádem poèítaèe na nedostatek pamìti zásobníku).
Faktoriál je tak vlastnì definován pomocí faktoriálu.</P>
<P>Výhodou rekurze také je, ¾e volání funkce nemusí být provedeno na
konci algoritmu ale i na jeho zaèátku èi uprostøed. Èást algoritmu se
tedy provádí pøi pøímé a èást a¾ pøi zpìtné cestì rekurzí. Jako
pøíklad mù¾e slou¾it tisk hodnot faktoriálu od nuly do daného èísla &ndash;
u rekurzivního algoritmu faktoriálu se to dá vyøe¹it tiskem hodnoty
po návratu z volání funkce s men¹ím parametrem. <BR>Dal¹ím pøíkladem
je zpùsob urèení poloviny intervalu neznáme-li pøedem jeho délku
(pou¾ito v programovacím jazyce Karel). Potom se dá pou¾ít rekurzivní
algoritmus. Jeho základem je pravidlo, ¾e doprostøed intervalu se
dostaneme tak, ¾e na ka¾dé dva kroky vpøed udìláme krok vzad.
Rekurentní pravidlo spoleènì s podmínkou ukonèení lze napsat: Udìlej
dva kroky a pokud nejsi u zdi, pou¾ij tento návod, potom udìlej krok
zpìt. (Prùbìh algoritmu je na následujícím obrázku, ka¾dý obdélník
znaèí jednotlivé volání té¾e funkce. Pozn. po volání funkce se
vracíme na následující èást programu).</P>
<P><IMG SRC="01_faktorial_html_5ca2673b.gif" NAME="obrázky1" ALIGN=BOTTOM WIDTH=663 HEIGHT=309 BORDER=0></P>
<P>Nevýhodou rekurzivního volání funkcí je velká pamì»ová nároènost &ndash;
pøi ka¾dém volání se vytváøí nové lokální parametry, volané a
návratové hodnoty. Jeliko¾ se jedná o nestandardnì velké po¾adavky na
zásobník, mù¾e dojít k jeho pøeteèení a chybám programu. Pøekladaèe
proto mají volbu na nastavení velikosti zásobníku.</P>
<P>Vìt¹ina rekurzivních funkcí se dá pøepsat pomocí cyklù &ndash;
jejich pou¾ití je tedy otázkou zhodnocení jejich výhodnosti oproti
tomuto øe¹ení. Rekurzi si uká¾eme na výpoètu faktoriálu (i kdy¾ je
èasto zmiòován jako nevhodný pøíklad pou¾ití, jedná se o jednoduchý a
známý algoritmus (a z tohoto hlediska je tedy vhodný jako první
ukázka této programovací techniky)).</P>
<P><BR><BR>
</P>
<P><FONT SIZE=4 STYLE="font-size: 16pt"><B>Úkol:</B></FONT></P>
<P><SPAN STYLE="background: transparent">V souboru mainfaktorial.c
vypoètìte faktoriál (tøemi &bdquo;zpùsoby&ldquo;). Dodr¾ujte pøesnì
po¾adovaný formát tisku.</SPAN></P>
<P><SPAN STYLE="background: transparent">0) Naètìte (funkcí scanf)
dvì celá èísla oddìlená èárkou (pou¾ijte typ long long (formátovací
øetìzec je &ldquo;%lld&ldquo;) a int). První celé èíslo je hodnota
její¾ faktoriál se bude poèítat. Druhé èíslo bude nula nebo jedna
(udává, zda se provede bod èíslo 4 zadání). Pro výpoèty vyu¾ívejte
typ unsigned long long int. Pokud se nenaètou dva parametry, nebo
druhé èíslo nebude jedna èi nula, vypi¹te text &bdquo;chybne zadani&ldquo;
a program ukonèete s chybovým kódem 1. Pokud bude první èíslo
záporné, vypi¹te text &bdquo;chybne zadani&ldquo; a program ukonèete
s chybovým kódem 2.<BR>1) Napi¹te kód realizující výpoèet faktoriálu
(nerekurzivní) pøímo ve funkci main. Vytisknìte ve funkci main
faktoriál zadaného èísla (z bodu 0). Vytisknìte pouze výsledek
(èíslo) na zaèátek øádku a odøádkujte. Výpoèet a tisk výsledku
proveïte pouze je-li parametr pro výpoèet správnì zadán.<BR>2)
Napi¹te funkci (se jménem faktnerek) poèítající faktoriál
(nerekurzivní). Funkce vrací faktoriál èísla zadaného jako parametr.
Vypoètìte pro zadané èíslo faktoriál. Vytisknìte výsledek jako v
pøedchozím bodì. <BR>3) Napi¹te funkci (se jménem faktrek),
poèítající faktoriál, výpoèet realizovaný rekurzivnì. Funkce vrací
faktoriál èísla zadaného jako parametr.</SPAN></P>
<P><SPAN STYLE="background: transparent">4) Vyu¾ijte funkci z bodu 3
(vytvoøte kopii se jménem faktrektisk) tak, aby pøi jediném jejím
volání vytiskla tato funkce tabulku faktoriálù pro èísla od 0 (nuly)
do zvoleného èísla. Tuto funkci zavolejte pouze, mìlo-li druhé zadané
èíslo hodnotu 1. Formát tisku je: od zaèátku øádku je pole desíti
znakù do kterých je vyti¹tìna hodnota èísla ze kterého se aktuálnì
poèítá faktoriál (zarovnáno na pravý kraj tohoto pole), potom
následuje pole tøiceti znakù, do kterého se vytiskne faktoriál
aktuální hodnoty (zarovnáno na pravý kraj tohoto pole). Ka¾dá dvojice
(hodnota + výsledek) má vlastní øádek.</SPAN></P>
<P><SPAN STYLE="background: transparent">Pokud funkce main skonèí bez
chyby, vrací hodnotu 0.</SPAN></P>
<P><BR><BR>
</P>
<P><A HREF="test_cv1_fact.zip">Testovací soubory.</A></P>
<P><BR><BR>
</P>
<P>Jaký je vhodný datový typ pro realizaci promìnných pro výpoèet
faktoriálu? Jaké jsou rozdíly (výhody/nevýhody pou¾ití rùzných
datových typù).</P>
<P>Jaké je maximální èíslo (pro zvolený datový typ) jeho¾ faktoriál
se dá vypoèítat? Navrhnìte jak toto èíslo zjistit.</P>
<P>Pøedstavte si, jaký je rozdíl v pou¾ití pamì»i (volání funkce,
ulo¾ení promìnných &hellip;) pøi realizace funkce podle bodu 2 a 3.</P>
<P><BR><BR>
</P>
<P><B>Poznámky:</B></P>
<P>Faktoriál je oznaèován &bdquo;!&ldquo; (faktoriál pìti je:
5!=5*4*3*2*1*1= 120 ,10! = 3628800,
1000!&nbsp;=&nbsp;4,02387260077093773543702433923e+2567). Definice
funkce faktoriál je:<BR>i ! je pro kladná i roven souèinu (i * (i-1)
* (i-2) * &hellip; 4 * 3 * 2 * 1). <BR>Pro i=0 je i! = 1.</P>
<P>Zároveò je mo¾né faktoriál definovat i jako rekurentní vztah (v
definici se objeví tatá¾ funkce)<BR>i ! je pro kladná i roven (i *
(i-1)! ) <BR>pro i = 0 je i! = 1.</P>
<P><BR><BR>
</P>
<P><FONT SIZE=4><B>Roz¹íøení úkolu</B></FONT> (na cvièeních pro
rychlej¹í studenty)</P>
<P>Na základì pøíkladu (example) na adrese
<A HREF="http://msdn.microsoft.com/en-us/vstudio/4e2ess30(v=vs.105).aspx">http://msdn.microsoft.com/en-us/vstudio/4e2ess30(v=vs.105).aspx</A>
(msdn time.h clock) zkuste zjistit kolik èasu jednotlivé funkce
zaberou pro výpoèet èísla MAX. (V pøípadì, ¾e je èasový interval
malý, je vhodné zavolat funkci nìkolikrát a vypoèítat prùmìrný èas).</P>
<P STYLE="margin-bottom: 0cm"><CODE CLASS="western">Upravený pøíklad
z uvedené adresy
<BR><A HREF="http://msdn.microsoft.com/en-us/vstudio/4e2ess30(v=vs.105).aspx">http://msdn.microsoft.com/en-us/vstudio/4e2ess30(v=vs.105).aspx</A></CODE></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<DIV ID="BodyBackground" DIR="LTR">
	<P><BR><BR>
	</P>
	<DIV ID="JelloSizer" DIR="LTR">
		<P><BR><BR>
		</P>
		<DIV ID="JelloExpander" DIR="LTR">
			<P><BR><BR>
			</P>
			<DIV ID="JelloWrapper" DIR="LTR">
				<P><BR><BR>
				</P>
				<DIV ID="mainSection" DIR="LTR">
					<P><BR><BR>
					</P>
					<DIV ID="mainBody" DIR="LTR">
						<PRE CLASS="western"><A NAME="c_afe54cd2a16a445c846f27354bb6cb7d"></A><CODE CLASS="western">// crt_clock.c</CODE>
<CODE CLASS="western">// This example displays the elapsed time for given program period.</CODE>
<CODE CLASS="western">//</CODE>

<CODE CLASS="western">#include &lt;stdio.h&gt;</CODE>
<CODE CLASS="western">#include &lt;stdlib.h&gt;</CODE>
<CODE CLASS="western">#include &lt;time.h&gt;</CODE>

<CODE CLASS="western">int main( void )</CODE>
<CODE CLASS="western">{</CODE>
<CODE CLASS="western">   </CODE><CODE CLASS="western">long    i = 6000000L;</CODE>
<CODE CLASS="western">   </CODE><CODE CLASS="western">clock_t start, finish;</CODE>
<CODE CLASS="western">   </CODE><CODE CLASS="western">double  duration;</CODE>

<CODE CLASS="western">   </CODE><CODE CLASS="western">// Measure the duration of an event.</CODE>
<CODE CLASS="western">   </CODE><CODE CLASS="western">printf( &quot;Time to do %ld empty loops is &quot;, i );</CODE>
<CODE CLASS="western">   </CODE><CODE CLASS="western">start = clock();</CODE>
<CODE CLASS="western">   </CODE><CODE CLASS="western">while( i-- ) </CODE>
<CODE CLASS="western">      </CODE><CODE CLASS="western">;</CODE>
<CODE CLASS="western">   </CODE><CODE CLASS="western">finish = clock();</CODE>
<CODE CLASS="western">   </CODE><CODE CLASS="western">duration = (double)(finish - start) / CLOCKS_PER_SEC;</CODE>
<CODE CLASS="western">   </CODE><CODE CLASS="western">printf( &quot;%2.1f seconds\n&quot;, duration );</CODE>
<CODE CLASS="western">}</CODE></PRE>
					</DIV>
				</DIV>
			</DIV>
		</DIV>
	</DIV>
</DIV>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P>Poslední zmìna 2017-02-14</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
</BODY>
</HTML>