<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0082)http://www.uamt.feec.vutbr.cz/~richter/vyuka/PC2A/cviceni/11_structkomplex.html.cs -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
	
	<title></title>
	<meta name="GENERATOR" content="OpenOffice 4.0.1  (Win32)">
	<meta name="CREATED" content="20140421;13480532">
	<meta name="CHANGED" content="20150501;15411122">
	<style type="text/css">
	<!--
		@page { size: 21cm 29.7cm; margin-left: 2cm; margin-right: 1cm; margin-top: 1cm; margin-bottom: 1cm }
		P { margin-bottom: 0.21cm }
		A:link { color: #000080; so-language: zxx; text-decoration: underline }
		A:visited { color: #800000; so-language: zxx; text-decoration: underline }
	-->
	</style>
</head>
<body lang="cs-CZ" link="#000080" vlink="#800000" dir="LTR">
<p align="CENTER"><font size="5"><b>Struktura &#8211; komplexní èísla</b></font></p>
<p><br><br>
</p>
<p>Komplexní èíslo patøí ke slo¾itìj¹ímu datovému typu &#8211; skládá
se ze dvou slo¾ek : Imaginární a Reálné (lze pou¾ít i dvojici
amplituda a úhel, pøístup k programování je zde stejný). Pro práci s
promìnnými, které se skládají z více promìnných slou¾í datový typ
struktura. Definicí struktury &#8222;vznikne&#8220; nový datový typ
jeho název je &#8222;<font face="Courier New, monospace">struct
Jmeno</font>&#8220; (to znamená, ¾e stejnì jako jsme pou¾ívali typ
<font face="Courier New, monospace">int</font> nyní mù¾eme (na místo
int) psát &#8222;<font face="Courier New, monospace">struct Jmeno</font>&#8220;).</p>
<ol>
	<li><p>Vytvoøte projekt se soubory <font face="Courier New, monospace">main.c</font>
	(zde naprogramujte funkci <font face="Courier New, monospace">main</font>),
	<font face="Courier New, monospace">komplex.c</font> a <font face="Courier New, monospace">komplex.h</font>.
	Soubor <font face="Courier New, monospace">komplex.h</font> o¹etøete
	proti vícenásobnému naètení (podmínìný pøeklad) a hlavièkový soubor
	vlo¾te do obou zdrojových souborù (*.c).</p>
	</li><li><p>V souboru <font face="Courier New, monospace">komplex.h</font>
	bude v¹e co pøi kompilaci nevytváøí pøímý kód (prototyp struktury,
	funkcí, &#8230;) v souboru <font face="Courier New, monospace">komplex.c</font>
	bude to co tvoøí kód (funkce s tìlem, definice promìnných).</p>
	</li><li><p>Navrhnìte a naprogramujte strukturu <font face="Courier New, monospace">TKomplex</font>,
	která má dvì slo¾ky &#8211; <font face="Courier New, monospace">iRe,
	iIm.</font> Pro slo¾ky zvolte vhodný datový typ. Popis struktury
	umístìte do hlavièkového souboru <font face="Courier New, monospace">komplex.h</font>.
	Ve funkci <font face="Courier New, monospace">main</font>
	nadefinujte dvì promìnné typu <font face="Courier New, monospace">struct
	TKomplex</font> s názvy <font face="Courier New, monospace">aa, bb,</font>
	a dva ukazatele na typ <font face="Courier New, monospace">struct
	TKomplex </font>s názvy <font face="Courier New, monospace">pa, pb</font>.</p>
	</li><li><p>Promìnnou <font face="Courier New, monospace">aa</font>
	inicializujte pøímo v definici na hodnotu <font face="Courier New, monospace"><font size="2" style="font-size: 11pt"><span lang="en-US">{</span></font></font><font face="Courier New, monospace"><font size="2" style="font-size: 11pt">1.1,
	2.2}</font></font>. Hodnoty promìnné <font face="Courier New, monospace">bb</font>
	nastavte/inicializujte pomocí samostatných pøiøazovacích pøíkazù
	(pøiøazení pomocí operátoru = pro jednotlivé slo¾ky struktury) na
	hodnotu <font face="Courier New"><font size="2" style="font-size: 11pt">{3.3,
	4.4}</font></font>. Ukazatel <font face="Courier New, monospace">pb</font>
	nastavte tak, aby ukazoval na promìnnou <font face="Courier New, monospace">bb</font>.</p>
	</li><li><p>Ve funkci <font face="Courier New, monospace">main</font>
	vytisknìte promìnné <font face="Courier New, monospace">aa</font> a
	<font face="Courier New, monospace">bb</font> ve formátu
	&#8220;(<font face="Courier New"><font size="2" style="font-size: 11pt">1.1+2.2i)</font></font>&#8220;
	(shodnotami pro promìnnou <font face="Courier New, monospace">aa)</font>.
	Vytisknìte i druhou promìnnou <font face="Courier New, monospace">bb</font>,
	ale tentokrát pomocí ukazatele <font face="Courier New, monospace">pb</font>
	(z pøedchozího bodu), který na ni ukazuje.</p>
	</li><li><p>a) Napi¹te funkci <font face="Courier New, monospace">Print</font>
	pro tisk (struktury) komplexního èísla ve formátu z minulého bodu.
	Promìnnou pøedejte hodnotou jako jediný parametr funkce <font face="Courier New, monospace">Print</font>,
	tj. <font face="Courier New, monospace">struct</font>
	<font face="Courier New, monospace">TKomplex</font>.<br>Proto¾e
	funkce pro tisk nemìní promìnnou (a ani by ji z podstaty chápání
	tisku mìnit nemìla), je vhodné u typu parametru pou¾ít modifikátor
	<font face="Courier New, monospace">const</font>, tedy : <font face="Courier New, monospace">const
	struct TKomplex aVal.</font> Uvedení modifikátoru <font face="Courier New, monospace">const</font>
	má význam pro programátora, nebo» pøekladaè provede kontrolu, zda se
	parametr v tìle skuteènì nemodifikuje. V pøípadì pokusu o zmìnu
	promìnné zahlásí pøekladaè pøi pøekladu chybu.<br>Funkci roz¹iøte o
	dal¹í parametr typu øetìzec, který se vytiskne pøedtím, ne¾ se
	vytiskne èíslo (v tomto øetìzci mù¾e být napøíklad komentáø &#8220;<i>Soucet
	cisel je:</i><font face="Times New Roman, serif"><font size="2" style="font-size: 11pt"><i>&#765;</i></font></font>&#8220;).
	Nebude-li text po¾adován, pou¾ijte pøi volání hodnotu NULL, a ve
	funkci tento stav o¹etøete.<br>b) (DU) Napi¹te druhou funkci pro
	tisk <font face="Courier New, monospace">PrintP</font> tak, aby byl
	parametrem ukazatel tj. <font face="Courier New, monospace">struct
	TKomplex*</font>. Pøidáme-li promìnnou pro poèet prvkù <font face="Courier New, monospace">aLen</font>,
	mù¾eme tuto funkci pou¾ít nejen pro tisk jedné promìnné, ale i pro
	tisk polí (prvky vyti¹tìné podle pøíkladu 4 oddìlené (napøíkald)
	mezerou). <br><font face="Courier New, monospace">int </font><font face="Courier New, monospace"><span lang="en-US">PrintP(const
	struct</span></font> <font face="Courier New, monospace">TKomplex
	*aData, unsigned aLen, char *aTxt)</font><br>Podobnì jako u pøedání
	hodnotou je mo¾né oznaèit modifikátorem <font face="Courier New, monospace">const</font>
	i hodnoty pøedávané pomocí ukazatele: <br><font face="Courier New, monospace">const
	struct TKomplex* const</font>. (blí¾e viz. bod 6)<br>c) Srovnejte
	výhody a nevýhody pøedání strukutry pomocí hodnoty a pomocí
	ukazatele.</p>
	</li><li><p>Napi¹te funkci <font face="Courier New, monospace">int
	SwapParts(const struct TKomplex * const aIn, struct TKomplex * const
	aOut).</font><br><font face="Times New Roman, serif"><font size="3">Struktura
	pøedstavuje tzv. slo¾ený datový typ. Jeho velikost je tedy závislá
	na poètu a velikosti v¹ech slo¾ek. Pøi pøedávání hodnotou dochází ke
	kopírování celé struktury do pamì»ové oblasti zásobníku, co¾
	pøedstavuje èasovì a pamì»ovì nároènou operaci. Abychom se tìmto
	operacím vyhnuli, je vhodné zvá¾it, zda nepøedat do funkce jako
	parametr pouze ukazatel na ji¾ existující strukturu. Parametr </font></font><font face="Courier New, monospace"><font size="3">aIn</font></font>
	<font face="Times New Roman, serif"><font size="3">pøedstavuje nemìnný
	ukazatel na nemìnnou hodnotu vstupního komplexního èísla a parametr
	</font></font><font face="Courier New, monospace"><font size="3">aOut</font></font>
	<font face="Times New Roman, serif"><font size="3">pøedstavuje nemìnný
	ukazatel na výstupní hodnotu typu </font></font><font face="Courier New, monospace"><font size="3">struct
	TKomplex</font></font><font face="Times New Roman, serif"><font size="3">.
	</font></font><br>Funkce ulo¾í vstupní komplexní èíslo do výstupního
	tak, ¾e jeho slo¾ky budou vymìnìny <font face="Courier New, monospace"><font size="3">iIm&lt;=&gt;iRe</font></font>
	(oproti pùvodní promìnné). <br>Pozn.: Zkuste volání se stejnou
	promìnnou pro oba parametry tj. <font face="Courier New, monospace">SwapParts(&amp;a,
	&amp;a)</font> &#8211; v èem mù¾e být problém?</p>
	</li><li><p>Vyu¾ití ukazatelù v parametruch ov¹em vy¾aduje kontrolu
	hodnot ukazatelù na <font face="Courier New, monospace"><font size="3">NULL</font></font>.
	Doplòte tyto kontroly do tìla funkce a zajistìte navrácení chybové
	hodnoty.</p>
	</li><li><p>Napi¹te funkci <font face="Courier New, monospace">struct
	TKomplex Add(const struct TKomplex aVal1, const struct TKomplex
	aVal2)</font>, která seète dvì komplexní promìnné a výsledek vrátí
	jako návratovou hodnotu. Jeliko¾ je výsledkem promìnná její¾ prvky
	jsou rùzné od existujících promìnných, musí pro ni vzniknout nová
	promìnná. 
	</p>
	<p>Ve funkci <font face="Courier New, monospace"><font size="3">main</font></font>
	nadefinujte pole komplexních èísel <font face="Courier New, monospace"><font size="3">struct
	TKomplex</font></font> (délka pole bude zadána pomocí makra <font face="Courier New, monospace"><font size="3">#define
	N 10</font></font>. Prvky pole naplòte v cyklu hodnotami <font face="Courier New, monospace"><font size="3">iRe
	= (i-5)*(i-5); Imag = i;</font></font>, kde i se mìní od 0 do N.
	Napi¹te funkci <font face="Courier New, monospace"><font size="3">Sort</font></font>,
	která seøadí pole komplexních èísel <font face="Courier New, monospace"><font size="3">aValues</font></font>
	o délce <font face="Courier New, monospace"><font size="3">aLen</font></font>
	na základì jejich velikosti (velikost komplexního èísla je
	definovaná jako odmocnina ze souètu kvadrátù slo¾ek). <br><font face="Courier New, monospace"><font size="3">int
	Sort(struct TKomplex aValues[], const unsigned aLen)</font></font>.<br>Pozn.
	K øazení je mo¾né vyu¾ít knihovní funkce <font face="Courier New, monospace"><font size="3">qsort</font></font>
	(vy¾aduje hlavièkový soubor <font face="Courier New, monospace"><font size="3">stdlib.h</font></font>).<br>O¹etøete
	chyby vzniklé zadáním ¹patných hodnot u obou parametrù funkce
	<font face="Courier New, monospace"><font size="3">Sort</font></font>.<br>Pùvodní
	a seøazené pole vytisknìte pomocí funkce <font face="Courier New, monospace"><font size="3">Print</font></font>
	(<font face="Courier New, monospace"><font size="3">PrintP</font></font>).<br><br>DU:
	Promyslete situaci, kdy by pro výsledné setøídìné pole mìla být
	pou¾ita nová promìnná. Bylo by tedy nutné pro výsledné pole
	naalokovat místo a pøedat ho zpìt do volající funkce. Zhodno»te
	vhodnost následujících hlavièek funkce k tomuto úèelu? Promyslete i
	volání tìchto funkcí vèetnì definice promìnných (a nutnost
	odalokovat naalokovanou pamì»).<br><font face="Courier New, monospace">struct
	TKomplex* Sort(const struct TKomplex *aData, int </font><font face="Courier New, monospace"><span lang="en-US">aLen</span></font><font face="Courier New, monospace">);<br>struct
	TKomplex* Sort(const struct TKomplex aData[], int </font><font face="Courier New, monospace"><span lang="en-US">aLen</span></font><font face="Courier New, monospace">);<br>struct
	TKomplex Sort(const struct TKomplex *aData, int </font><font face="Courier New, monospace"><span lang="en-US">aLen</span></font><font face="Courier New, monospace">);<br>struct
	TKomplex Sort(const struct TKomplex aData[], int </font><font face="Courier New, monospace"><span lang="en-US">aLen</span></font><font face="Courier New, monospace">);<br>int
	Sort(const struct TKomplex *aData, int </font><font face="Courier New, monospace"><span lang="en-US">aLen</span></font><font face="Courier New, monospace">,
	struct TKomplex *aOut);<br>int Sort(const struct TKomplex aData[],
	int </font><font face="Courier New, monospace"><span lang="en-US">aLen</span></font><font face="Courier New, monospace">,
	struct TKomplex aOut[]);<br>int Sort(const struct TKomplex aData[],
	int </font><font face="Courier New, monospace"><span lang="en-US">aLen</span></font><font face="Courier New, monospace">,
	struct TKomplex *aOut);<br>int Sort(const struct TKomplex aData[],
	int </font><font face="Courier New, monospace"><span lang="en-US">aLen</span></font><font face="Courier New, monospace">,
	struct TKomplex **aOut);<br></font><br><br>
	</p>
	</li><li><p> (DU) Pro funkci Add je mo¾né volit rùzná øe¹ení parametrù.
	Promyslete jednotlivé následující typy volání, z nich¾ pomocí v¹ech
	je mo¾né po¾adovanou funkci splnit. Srovnejte jednotlivá øe¹ení z
	ohledem na velikost pou¾ité pamìti pøi pøedávání parametrù a zpùsobu
	naprogramování. Nezapomeòte uva¾ovat i volání funkcí vèetnì definice
	pou¾itých promìnných. Diskutujte ne/výhodnost øe¹ení pou¾ívajících
	dynamickou alokaci pamìti.<br>(Tìla funkcí jsou pouze náznakem).</p>
</li></ol>
<p><br><br>
</p>
<p>struct TKomplex Add(struct TKomplex s1,struct TKomplex
s2)<br>{<br>struct TKomplex pom;<br><br> return pom;<br>}</p>
<p><br><br>
</p>
<p>struct TKomplex Add(struct TKomplex *s1,struct TKomplex
*s2)<br>{<br>struct TKomplex pom;<br><br> return pom;<br>}</p>
<p><br><br>
</p>
<p>struct TKomplex* Add(struct TKomplex s1,struct TKomplex
s2)<br>{<br>struct TKomplex *pom = malloc();<br><br> return pom;<br>}</p>
<p><br><br>
</p>
<p>struct TKomplex* Add(struct TKomplex *s1,struct TKomplex *s2)<br>{<br>
struct TKomplex *pom = malloc();<br><br> return pom;<br>}</p>
<p><br><br>
</p>
<p>int Add(struct TKomplex *s1,struct TKomplex *s2,struct TKomplex
*s3)<br>{<br><br> return 0;<br>}</p>
<p><br><br>
</p>
<p>int Ukazatele3(struct TKomplex *s1,struct TKomplex *s2,struct
TKomplex **s3)<br>{<br> *s3 = malloc();<br><br> return 0;<br>}</p>
<p><br><br>
</p>
<p><br><br>
</p>
<p><br><br>
</p>
<p>Poslední zmìna 2015-04-30</p>
<p><br><br>
</p>
<p><br><br>
</p>
<p><br><br>
</p>
<p><br><br>
</p>
<p><br><br>
</p>
<p><br><br>
</p>

</body></html>